@namespace Chats
@using LuminaryVisuals.Components.Shared.Chat
@inject ChatService ChatService
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IScrollManager ScrollManager
@inject IJSRuntime JSRuntime
@inject ILogger<ProjectChatDialog> Logger
@implements IDisposable
@inject IMessageNotificationService MessageNotificationService


<MudContainer Class="chat-container">
        <MudPaper Elevation="4" Class="chat-panel">
            <MudPaper Elevation="3" Class="chat-header" Outlined="true">
                    <MudIconButton  Icon="@Icons.Material.Filled.ArrowBack" OnClick="NavigateBack" Class="back-button" />
                <MudText Typo="Typo.h6" Class="chat-title">
                    <MudIcon Icon="@Icons.Material.Filled.Chat" Class="mr-3" />
                    Chat
                </MudText>
                <MudIconButton Icon="@Icons.Material.Filled.Close" Color="Color.Info" OnClick="Close" />
            </MudPaper>
            <MudContainer Class="chat-content" Gutters="false"  @onscroll="OnScroll">
                @if (hasMoreMessages)
                {
                    <div class="load-more-indicator">Loading more messages...</div>
                }

                <div class="chat-messages">
                    @foreach (var group in messages.GroupBy(m => GetDisplayDate(m.Timestamp)))
                    {
                        <MudText Typo="Typo.subtitle2" Align="Align.Center" Class="date-separator">
                            @group.Key
                        </MudText>
                                @foreach (var (message, index) in group.Select((m, i) => (m, i)))
                                {
                                if(lastUserId != message.UserId){
                                    <MudText Typo="Typo.caption" Class="message-username">@(message.UserId != UserId && !isClientView
                                        ? message.User.UserName
                                        : message.UserId != UserId && isClientView ? "Luminary Visuals" : "")
                                    </MudText> 
                                    lastUserId = message.UserId; 
                                }
                            <div class="message-container @(message.UserId == UserId ? "message-right" : "message-left")" @ontouchstart="ToggleClick"
                            style="--total-messages:@messages.Count; --message-index:@index;">


                                <div class="chat-message @(message.IsApproved == false ? "not-approved-message" : "" )">
                                @foreach (var part in GetMessageWithLinks(message.Content))
                                    {
                                        if (StringHelper.IsLink(part))
                                        {
                                            <strong><MudLink Typo="Typo.body1" Class="special-link" Href="@part" 
                                                Underline="Underline.Always">@part </MudLink></strong>
                                        }
                                        else
                                        {
                                            <MudText Typo="Typo.body1">@part</MudText>
                                        }
                                    }
                                <MudText Typo="Typo.caption" Class="message-timestamp">
                                    @ConvertLocal.ConvertToLocalTime(message.Timestamp,timezoneOffsetMinutes)
                                    <MudIcon Class="received-icon" Icon="@Icons.Material.Filled.Check" Color="Color.Success"></MudIcon>
                                </MudText>
                                </div>
                                @if (message.UserId == UserId || isAdminView == true)   
                                {
                                <div class="message-hover-options" style="@(isClicked == true ? "display: flex !important;" : "display:none;")" >
                                @if (isAdminView)
                                {
                                    <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                    Color="Color.Error"
                                    Size="Size.Small"
                                    OnClick="() => DeleteMessage(message)"/>
                                    if (message.IsApproved == false)
                                    {
                                        <MudIconButton Icon="@Icons.Material.Filled.CheckCircleOutline" Color="Color.Success" 
                                        Size="Size.Small" OnClick="() => ApproveMessage(message)"/>
                                    }
                                    }
                                    <MudIconButton Icon="@Icons.Material.Filled.Edit" Color="Color.Primary" Size="Size.Small"
                                    OnClick="() => EditMessage(message)"  />
                                </div>
                                    }

                            </div>
                            }
                    }
                </div>
            </MudContainer>
            <MudPaper Class="chat-input-area" Elevation="0">
                <MudTextField @bind-Value="newMessage" Placeholder="Type a message..." Variant="Variant.Outlined" Clearable=true DebounceInterval="5"
                Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Send" TextUpdateSuppression="false" OnAdornmentClick="SendMessage"
                AutoFocus="true" OnKeyDown="HandleKeyPress" /> 
            </MudPaper>
    </MudPaper>
</MudContainer>

@code {
    [CascadingParameter]
    MudDialogInstance MudDialog { get; set; }
    [Parameter] public int ProjectId { get; set; }
    [Parameter] public string UserId { get; set; }
    [Parameter] public bool isAdminView { get; set; }
    [Parameter] public bool isEditorView { get; set; }
    [Parameter] public bool isClientView { get; set; }
    [Parameter] public int timezoneOffsetMinutes { get; set; }

    private bool isClicked = false;
    private string newMessage;
    private List<Message> messages = new List<Message>();
    private string lastUserId = null;
    private int? HighlightedMessageId;
    private IDisposable _subscription;
    private const int PAGE_SIZE = 50; 
    private int currentPage = 1;
    private bool hasMoreMessages = true;
    private bool finishedLoading = false;
    private bool _isInitialScrollComplete = false;
    public void Dispose()
    {
        _subscription?.Dispose();
    }
    protected override async Task OnInitializedAsync()
    {
        await LoadMessages(true);
        await MarkMessagesAsRead();
        _subscription = MessageNotificationService.Subscribe(ProjectId, async (newMessage) =>
        {
            // Check if the message is for this project
            if (ProjectId == ProjectId)
            {
                await InvokeAsync(async () =>
                {
                    await LoadMessages(true);
                });
            }
        });
        await ScrollManager.ScrollToBottomAsync(".chat-content", ScrollBehavior.Smooth);
        await JSRuntime.InvokeVoidAsync("setupInitialScrollListener", DotNetObjectReference.Create(this));
    }
    private void ToggleClick()
    {
        isClicked = !isClicked;
    }
    private async Task LoadMessages(bool initial = true)
    {
        try
        {
            finishedLoading = false;
            int pageToLoad = initial ? 1 : currentPage;
            var loadedMessages = await ChatService.GetMessagesAsync(ProjectId, isClientView, pageNumber: currentPage, pageSize: PAGE_SIZE);

            if (initial)
            {

                // First load - clear existing messages
                messages.Clear();
                await ScrollManager.ScrollToBottomAsync(".chat-content", ScrollBehavior.Smooth);
            }
            else
            {
                // Append messages to the beginning of the list
                messages.InsertRange(0, loadedMessages);
            }
            if (initial)
            {
                messages.AddRange(loadedMessages);
            }
            else
            {
                var currentScrollPosition = await JSRuntime.InvokeAsync<int>("getCurrentScrollPositionFromBottom", ".chat-content");

                // Prepend new messages to the beginning of the list
                messages.InsertRange(0, loadedMessages);

                // Restore scroll position
                await JSRuntime.InvokeVoidAsync("restoreScrollPositionFromBottom", ".chat-content", currentScrollPosition + loadedMessages.Count);
            }

            // Determine if there are more messages to load
            hasMoreMessages = loadedMessages.Count == PAGE_SIZE;

        }
        catch (Exception ex)
        {
            // Handle or log error
            Snackbar.Add($"Error loading messages",Severity.Error);
            Console.WriteLine($"Error loading messages: {ex.Message}");

        }

        finally{
            if (initial)
            {
                await ScrollManager.ScrollToBottomAsync(".chat-content", ScrollBehavior.Smooth);
            }
            StateHasChanged();
            finishedLoading = true;

        }
    }
    [JSInvokable]
    public async Task OnInitialScrollComplete()
    {
        await InvokeAsync(() =>
        {
            _isInitialScrollComplete = true;
            finishedLoading = true;
            StateHasChanged();
        });
    }

    private async Task MarkMessagesAsRead()
    {
        await ChatService.MarkMessagesAsReadAsync(ProjectId, UserId);
    }
    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(newMessage))
        {
            Snackbar.Add("Message cannot be empty", Severity.Warning);
            return;
        }
        try 
        {
            await ChatService.AddMessageAsync(ProjectId, UserId, newMessage, isEditorView);
            await MarkMessagesAsRead();
            await LoadMessages(initial: true);
            newMessage = string.Empty;
        }
        catch (Exception ex)
        {
            Snackbar.Add("Failed to send message", Severity.Error);
        }
    }

    private async Task OnScroll(EventArgs e)
    {
        // Skip processing if loading is finished or no more messages are available
        if (!_isInitialScrollComplete || !( finishedLoading && hasMoreMessages ))
        {
            return;
        }

        // Get the message index that is currently in view
        var messageIndexInView = await JSRuntime.InvokeAsync<string>("getElementWithMessageIndexInView", ".chat-content");

        // If no valid message index is in view, return early
        if (string.IsNullOrEmpty(messageIndexInView))
        {
            return;
        }

        // Try to parse the message index
        if (int.TryParse(messageIndexInView, out int messageIndex))
        {
            // Log the index for debugging purposes
            Console.WriteLine($"Message index in view: {messageIndex}");

            // Check if the message index is below a threshold to load more messages
            if (messageIndex <= 10)
            {
                currentPage++;
                await LoadMessages(initial: false);
            }
        }
        else
        {
            // Log error if message index parsing fails
            Logger.LogError($"Failed to parse message index: {messageIndexInView}");
        }
    }
    // Display date of each chat messages grouped by their date.
    string GetDisplayDate(DateTime timestamp)
    {
        var today = DateTime.Today;
        var daysDifference = ( today - timestamp.Date ).Days;

        if (timestamp.Date == today)
        {
            return "Today";
        }
        else if (timestamp.Date == today.AddDays(-1))
        {
            return "Yesterday";
        }
        else if (daysDifference <= 7)
        {
            return timestamp.DayOfWeek.ToString(); // Display the day of the week for messages within the past week
        }
        else if (daysDifference <= 14)
        {
            return "Last week";
        }
        else if (daysDifference <= 21)
        {
            return "2 weeks ago";
        }
        else if (daysDifference <= 28)
        {
            return "3 weeks ago";
        }
        else if (timestamp.Year == today.Year)
        {
            if (timestamp.Month == today.Month)
            {
                return $"Earlier this month";
            }
            else
            {
                return timestamp.ToString("MMMM dd"); // Display month and day if it is in a different month but same year
            }
        }
        else
        {
            return timestamp.ToString("MMMM dd, yyyy"); // Display full date for messages from a different year
        }
    }

    private bool _isContextMenuOpen = false;
    private IEnumerable<string> GetMessageWithLinks(string messageContent)
    {
        return StringHelper.GetTextAndLinks(messageContent);
    }
    private async Task DeleteMessage(Message message)
    {

        await ChatService.UnsendMessageAsync(ProjectId ,message.MessageId);
        await LoadMessages(initial: true);

    }
    private async Task ApproveMessage(Message message)
    {
        await ChatService.ApproveMessageAsync(ProjectId, message.MessageId);
        await LoadMessages(initial: true);
    }

    private async Task EditMessage(Message message)
    {
        try
        {
            if(UserId != message.UserId && isAdminView != true)
            {
                throw new Exception("The user is trying to modify a message that he he shouldn't be able to edit !!!");
            }
            var parameters = new DialogParameters<EditMessageDialog>
            {
                { x => x.Message, message },
                {"isAdminView", isAdminView},
                {"UserId", UserId}
            };  
            var dialog = await DialogService.ShowAsync<EditMessageDialog>("Edit Message", parameters);
            var result = await dialog.Result;
            if (!result.Canceled)
            {
                var editedContent = (string) result.Data;
                await ChatService.EditMessageAsync(message, ProjectId, editedContent, isEditorView);
                await LoadMessages(initial: true);
            }        
            else
            {
                Snackbar.Add("You have canceled the editing.", Severity.Warning);
            }
        }
        catch(Exception ex)
        {
            Logger.LogError($"The user is trying to modify a message that he he shouldn't be able to edit !!! This is the exception{ex}");
        }
    }


    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(newMessage))
        {
            await SendMessage();
        }
        if (e.Key == "Escape" && !string.IsNullOrWhiteSpace(newMessage))
        {
            await NavigateBack();
        }
    }
    private async Task NavigateBack()
    {
        var result = await ShowConfirmationDialog();
        if (!result.Canceled)
        {
            var options = new DialogOptions
            {
                CloseButton = true,
                Position = DialogPosition.BottomRight,
                NoHeader = true,
            };

            var parameters = new DialogParameters
            {
                { "userId", UserId },
                { "isAdminView", isAdminView },
                { "isEditorView", isEditorView },
                { "isClientView", isClientView },
                { "timezoneOffsetMinutes", timezoneOffsetMinutes },
            };
            MudDialog.Close();
            DialogService.Show<ChatProjectListDialog>("", parameters, options);

        }
    }
    private async Task Close()
    {
        var result = await ShowConfirmationDialog();
        if (!result.Canceled)
        {
            MudDialog.Close();
        }
    }

    private async Task<DialogResult> ShowConfirmationDialog()
    {
        if (!string.IsNullOrEmpty(newMessage))
        {
            var parameters = new DialogParameters
            {
                { "Message", "There is an unsent message. Are you sure you want to close?" }
            };

            var dialog = DialogService.Show<ConfirmationDialog>("Confirmation", parameters);

            return await dialog.Result;
        }

        return DialogResult.Ok(true); 
    }

}

<script>
    window.getTimezoneOffset = function () {
        return -new Date().getTimezoneOffset(); // Offset in minutes, negative for UTC-
    };
    window.getScrollTop = function (selector) {
        const element = document.querySelector(selector);
        return element ? element.scrollTop : 0;
    };
    window.setupInitialScrollListener = function (dotNetHelper) {
        const element = document.querySelector('.chat-content');
        if (!element) return;

        let hasUserScrolled = false;

        const scrollHandler = () => {
            if (!hasUserScrolled) {
                hasUserScrolled = true;
                // Invoke the .NET method
                dotNetHelper.invokeMethodAsync('OnInitialScrollComplete');
                element.removeEventListener('scroll', scrollHandler);
            }
        };

        element.addEventListener('scroll', scrollHandler);
    };
    window.getCurrentScrollPositionFromBottom = function (selector) {
        const element = document.querySelector(selector);
        if (!element) return 0;
        return element.scrollHeight - element.scrollTop - element.clientHeight;
    };

    window.restoreScrollPositionFromBottom = function (selector, additionalHeight) {
        const element = document.querySelector(selector);
        if (!element) return;
        element.scrollTop = element.scrollHeight - element.clientHeight - additionalHeight;
    };
    window.getElementWithMessageIndexInView = function (selector) {
        // Adjust selector to match chat-messages and message-container within it
        const elements = document.querySelectorAll(`${selector} .message-container`);
        let inView = null;

        elements.forEach(element => {
            const rect = element.getBoundingClientRect();

            // Check if the element is partially visible in the viewport
            if (rect.top <= window.innerHeight && rect.bottom >= 0) {
                inView = element;
            }
        });

        // Get the value of --message-index from the element in view
        const messageIndex = inView ? inView.style.getPropertyValue('--message-index') : null;
        return messageIndex;
    };



</script>
