@namespace Chats
@using LuminaryVisuals.Components.Shared.Chat
@inject ChatService ChatService
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IScrollManager ScrollManager
@inject IJSRuntime JSRuntime
@inject ILogger<ProjectChatDialog> Logger
@implements IDisposable
@inject IMessageNotificationService MessageNotificationService
@inject CloudflareR2Service CloudflareR2Service
@inject ProjectState ProjectState
<div @ref="chatContainerRef">
    <MudContainer Class="chat-container" Gutters=false>
        <MudPaper Elevation="4" Class="chat-panel">
            <MudPaper Elevation="3" Class="chat-header" Outlined="true">
                <MudIconButton  Icon="@Icons.Material.Filled.ArrowBack" OnClick="NavigateBack" Class="back-button" />
                <MudText Typo="Typo.h6" Class="chat-title">
                    <MudIcon Icon="@Icons.Material.Filled.Email" Class="mr-3" />
                    @Project.ProjectName
                </MudText>
                <MudIconButton Icon="@Icons.Material.Filled.Close" Color="Color.Info" OnClick="Close" />
            </MudPaper>
            <MudContainer Class="chat-content" Gutters="false"  @onscroll="OnScroll">

                <div class="chat-messages">
                    @if (hasMoreMessages)
                    {
                        <MudProgressCircular Color="Color.Info" Indeterminate="true" Style="margin-top:0px!important;align-self:center;position:relative;   "/>
                    }

                    @foreach (var group in messages.GroupBy(m => GetDisplayDate(ConvertLocal.ConvertToLocalTimeDateTime(m.Timestamp, timezoneOffsetMinutes))))
                    {
                        <MudText Typo="Typo.subtitle2" Align="Align.Center" Class="date-separator">
                            @group.Key
                        </MudText>
                        DateTime? lastTimestamp = null;
                        string lastUserId = null;
                        @foreach (var (message, index) in group.Select((m, i) => (m, i)))
                        {
                            if (lastUserId != message.UserId || ( lastTimestamp.HasValue && GetDisplayDate(lastTimestamp.Value) != GetDisplayDate(message.Timestamp) || lastUserId == null ))
                            {
                                <MudText Typo="Typo.body2" Class="message-username">@(message.UserId != UserId && !isClientView
                                        ? message.User.UserName
                                        : message.UserId != UserId && isClientView ? "Luminary Visuals" : "")
                                </MudText> 
                                lastUserId = message.UserId; 
                            }
                            <div class="message-container @(message.UserId == UserId ? "message-right" : "message-left")" @ontouchstart="ToggleClick"
                            style="--total-messages:@messages.Count; --message-index:@index;">


                                <div class="chat-message @(message.IsApproved == false ? "not-approved-message" : "" )">
                                    @foreach (var part in GetMessageWithLinks(message.Content))
                                    {
                                        if (StringHelper.IsLink(part))
                                        {
                                            // Check if the URL is an image based on the file extension
                                            if (ImageExtensions.Contains(Path.GetExtension(part)))
                                            {
                                                // Display the image
                                                <div class="spotlight" data-src="@part" data-download="true" @onclick:stopPropagation="true">
                                                    <img src="@part" style="max-width:100%; height:auto; max-height:50vw;" />
                                                </div>
                                            }
                                            else
                                            {
                                                <strong>
                                                    <MudLink Typo="Typo.body1" Class="special-link" Href="@part"
                                                    Underline="Underline.Always">@part </MudLink>
                                                </strong>
                                            }
                                        }
                                        else
                                        {
                                            <MudText Typo="Typo.body1">@part</MudText>
                                        }
                                    }
                                    <MudText Typo="Typo.caption" Class="message-timestamp">
                                        @ConvertLocal.ConvertToLocalTime(message.Timestamp,timezoneOffsetMinutes)
                                        <MudIcon Class="received-icon" Icon="@Icons.Material.Filled.Check" Color="Color.Success"></MudIcon>
                                    </MudText>
                                </div>
                                @if (message.UserId == UserId || isAdminView == true)   
                                {
                                    <div class="message-hover-options" style="@(isClicked == true ? "display: flex !important;" : "display:none;")" >
                                        @if (isAdminView)
                                        {
                                            <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                            Color="Color.Error"
                                            Size="Size.Small"
                                            OnClick="() => DeleteMessage(message)"/>
                                            <MudIconButton Icon="@Icons.Material.Filled.Info"
                                            Color="Color.Info"
                                            Size="Size.Small"
                                            OnClick="() => MessageInformation(message)" />
                                            if (message.IsApproved == false)
                                            {
                                                <MudIconButton Icon="@Icons.Material.Filled.CheckCircleOutline" Color="Color.Success" 
                                                Size="Size.Small" OnClick="() => ApproveMessage(message)"/>
                                            }
                                        }

                                        <MudIconButton Icon="@Icons.Material.Filled.Edit" Color="Color.Warning" Size="Size.Small"
                                        OnClick="() => EditMessage(message)"  />
                                    </div>
                                }

                            </div>
                        }
                    }
                </div>
                <LoadingIndicatorChat IsVisible="@_isLoading" />
            </MudContainer>
            <MudPaper Class="chat-input-area d-flex justify-center" Elevation="0" style="align-items:center;">
                <MudFileUpload T="IBrowserFile" FilesChanged="UploadFiles" Class="d-flex" Accept=".jpg, .jpeg, .png, .gif, .bmp, .tiff, .tif,
                .svg, .webp, .ico, .heic, .heif, .raw, .psd,.dds, .jp2, .j2k, .jpf, .eps, .ai">
                    <ActivatorContent>
                        <MudIconButton Style="color:#efefef"
                        Icon="@Icons.Material.Filled.AttachFile" Size="Size.Small" DropShadow=true Edge="Edge.Start" Ripple=true />
                    </ActivatorContent>
                </MudFileUpload>
                <MudTextField @bind-Value="newMessage" Class="flex-grow-1" Placeholder="Type a message..."
                Variant="Variant.Outlined" Clearable="true" @ref="messageField" Adornment="Adornment.End"
                AdornmentIcon="@Icons.Material.Filled.Send" OnAdornmentClick="( () => SendMessage(newMessage) )"
                TextUpdateSuppression=false AutoFocus="true" KeyDownPreventDefault=_preventDefault
                OnKeyDown="HandleKeyPress" AutoGrow=true MaxLines="6">
                </MudTextField>

            </MudPaper>
        </MudPaper>
    </MudContainer>
</div>
@code {
    [CascadingParameter]
    MudDialogInstance MudDialog { get; set; }
    [Parameter] public Project Project{ get; set; }
    [Parameter] public string UserId { get; set; }
    [Parameter] public bool isAdminView { get; set; }
    [Parameter] public bool isEditorView { get; set; }
    [Parameter] public bool isClientView { get; set; }
    [Parameter] public int timezoneOffsetMinutes { get; set; }
    IList<IBrowserFile> _files = new List<IBrowserFile>();
    private string? UploadedFileUrl;
    private bool isClicked = false;
    private string newMessage;
    private List<Message> messages = new List<Message>();
    private MudTextField<string> messageField = default!;
    private int? HighlightedMessageId;
    private IDisposable _subscription;
    private const int PAGE_SIZE = 50; 
    private int currentPage = 1;
    private bool hasMoreMessages = true;
    private bool finishedLoading = false;
    private bool _isInitialScrollComplete = false;
    private bool _isLoading;
    private static readonly HashSet<string> ImageExtensions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
    ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".tif",
    ".svg", ".webp", ".ico", ".heic", ".heif", ".raw", ".psd",
    ".dds", ".jp2", ".j2k", ".jpf", ".eps", ".ai"
    };
    public void Dispose()
    {
        ProjectState.OnChange -= HandleProjectChange;
        _subscription?.Dispose();
    }
    private async void HandleProjectChange()
    {
        // Immediately reload messages whenever the project changes
        await LoadMessages(true);  
        await MarkMessagesAsRead();
        StateHasChanged();  // Trigger a re-render after messages are loaded
    }
    protected override async Task OnInitializedAsync()
    {
        ProjectState.OnChange += HandleProjectChange;
        await LoadMessages(true);
        await MarkMessagesAsRead();
        _subscription = MessageNotificationService.Subscribe(Project.ProjectId, async (newMessage) =>
        {
            // Check if the message is for this project
            if (Project.ProjectId == Project.ProjectId)
            {
                await InvokeAsync(async () =>
                {
                    await LoadMessages(true);
                    await MarkMessagesAsRead();

                });
            }
        });
        await ScrollManager.ScrollToBottomAsync(".chat-content", ScrollBehavior.Smooth);
        await JSRuntime.InvokeVoidAsync("setupInitialScrollListener", DotNetObjectReference.Create(this));
        await JSRuntime.InvokeVoidAsync("document.body.classList.add", "chat-open");

    }
    private async Task UploadFiles(IBrowserFile file)
    {
        try
        {
            _isLoading = true;
            UploadedFileUrl = await CloudflareR2Service.UploadFileAsync(file);
            await SendMessage(UploadedFileUrl);
        }
        catch (Exception ex)
        {
            Snackbar.Add("Unsupported Format or file is larger than 10MB. Please attach the file using a link hosted on another cloud storage", Severity.Warning);
            Console.WriteLine($"Error uploading file: {ex}");
        }
        finally{
            _isLoading = false;
        }

    }
    private void ToggleClick()
    {
        isClicked = !isClicked;
    }
    private async Task LoadMessages(bool initial = true)
    {
        try
        {
            finishedLoading = false;
            int pageToLoad = initial ? 1 : currentPage;
            var loadedMessages = await ChatService.GetMessagesAsync(Project.ProjectId, isClientView, pageNumber: currentPage, pageSize: PAGE_SIZE);

            if (initial)
            {

                // First load - clear existing messages
                messages.Clear();
                await Task.Delay(500);
                await ScrollManager.ScrollToBottomAsync(".chat-content", ScrollBehavior.Smooth);
            }
            else
            {
                // Append messages to the beginning of the list
                messages.InsertRange(0, loadedMessages);
            }
            if (initial)
            {
                messages.AddRange(loadedMessages);
            }
            else
            {
                var currentScrollPosition = await JSRuntime.InvokeAsync<int>("getCurrentScrollPositionFromBottom", ".chat-content");

                // Prepend new messages to the beginning of the list
                messages.InsertRange(0, loadedMessages);

                // Restore scroll position
                await JSRuntime.InvokeVoidAsync("restoreScrollPositionFromBottom", ".chat-content", currentScrollPosition + loadedMessages.Count);
            }

            // Determine if there are more messages to load
            hasMoreMessages = loadedMessages.Count == PAGE_SIZE;

        }
        catch (Exception ex)
        {
            // Handle or log error
            Snackbar.Add($"Error loading messages. Please try again later, or refresh page if it persists please report this.",Severity.Error);
            Console.WriteLine($"Error loading messages: {ex.Message}");

        }

        finally{
            if (initial)
            {
                await ScrollManager.ScrollToBottomAsync(".chat-content", ScrollBehavior.Smooth);
            }
            StateHasChanged();
            finishedLoading = true;

        }
    }
    [JSInvokable]
    public async Task OnInitialScrollComplete()
    {
        await InvokeAsync(() =>
        {
            _isInitialScrollComplete = true;
            finishedLoading = true;
            StateHasChanged();
        });

    }

    private async Task MarkMessagesAsRead()
    {
        await ChatService.MarkMessagesAsReadAsync(Project.ProjectId, UserId);
    }
    private async Task<bool> SendMessage(string newMessage)
    {
        _isLoading = true;
        await messageField.BlurAsync();
        if (string.IsNullOrWhiteSpace(newMessage))
        {
            Snackbar.Add("Message cannot be empty", Severity.Warning);
            return false;
        }
        try 
        {
            await messageField.Clear();

            var message = await ChatService.AddMessageAsync(Project.ProjectId, UserId, newMessage, isEditorView);
            await MarkMessagesAsRead();
            newMessage = string.Empty;
            await messageField.FocusAsync();
            _isLoading = false;
            return true;
        }
        catch (Exception ex)
        {
            Snackbar.Add("Failed to send message", Severity.Error);
            Logger.LogError($"Failed to send message to server by SendMessage Method {ex} ");
            return false;
        }
    }

    private async Task OnScroll(EventArgs e)
    {
        // Skip processing if loading is finished or no more messages are available
        if (!_isInitialScrollComplete || !( finishedLoading && hasMoreMessages ))
        {
            return;
        }

        // Get the message index that is currently in view
        var messageIndexInView = await JSRuntime.InvokeAsync<string>("getElementWithMessageIndexInView", ".chat-content");

        // If no valid message index is in view, return early
        if (string.IsNullOrEmpty(messageIndexInView))
        {
            return;
        }

        // Try to parse the message index
        if (int.TryParse(messageIndexInView, out int messageIndex))
        {
            // Log the index for debugging purposes

            // Check if the message index is below a threshold to load more messages
            if (messageIndex <= 10)
            {
                currentPage++;
                await LoadMessages(initial: false);
            }
        }
        else
        {
            // Log error if message index parsing fails
            Logger.LogError($"Failed to parse message index: {messageIndexInView}");
        }
    }
    // Display date of each chat messages grouped by their date.
    string GetDisplayDate(DateTime timestamp)
    {
        var today = DateTime.Today;
        var daysDifference = ( today - timestamp.Date ).Days;

        if (timestamp.Date == today)
        {
            return "Today";
        }
        else if (timestamp.Date == today.AddDays(-1))
        {
            return "Yesterday";
        }
        else if (daysDifference <= 7)
        {
            return timestamp.DayOfWeek.ToString(); // Display the day of the week for messages within the past week
        }
        else if (daysDifference <= 14)
        {
            return "Last week";
        }
        else if (daysDifference <= 21)
        {
            return "2 weeks ago";
        }
        else if (daysDifference <= 28)
        {
            return "3 weeks ago";
        }
        else if (timestamp.Year == today.Year)
        {
            if (timestamp.Month == today.Month)
            {
                return $"Earlier this month";
            }
            else
            {
                return timestamp.ToString("MMMM dd"); // Display month and day if it is in a different month but same year
            }
        }
        else
        {
            return timestamp.ToString("MMMM dd, yyyy"); // Display full date for messages from a different year
        }
    }

    private bool _isContextMenuOpen = false;
    private IEnumerable<string> GetMessageWithLinks(string messageContent)
    {
        return StringHelper.GetTextAndLinks(messageContent);
    }
    private async Task DeleteMessage(Message message)
    {
        var parameters = new DialogParameters
            {
                { "Message", "Are you sure you want to delete this message?" }
            };

        var dialog = DialogService.Show<ConfirmationDialog>("Confirmation", parameters);
        var result = await dialog.Result;
        if (!result!.Canceled)
        {
            StateHasChanged();
            await ChatService.UnsendMessageAsync(Project.ProjectId, message.MessageId);
            await LoadMessages(initial: true);
        }

    }
    private async Task ApproveMessage(Message message)
    {
        await ChatService.ApproveMessageAsync(Project.ProjectId, message.MessageId);
        await LoadMessages(initial: true);
    }

    private async Task MessageInformation(Message message)
    {
        await DialogService.ShowMessageBox("Info",$"message sent at {message.Timestamp}", yesText: "Close");
        StateHasChanged();

    }
    private async Task EditMessage(Message message)
    {
        try
        {
            if(UserId != message.UserId && isAdminView != true)
            {
                throw new Exception("The user is trying to modify a message that he he shouldn't be able to edit !!!");
            }
            var parameters = new DialogParameters<EditMessageDialog>
            {
                { x => x.Message, message },
                {"isAdminView", isAdminView},
                {"UserId", UserId}
            };  
            var dialog = await DialogService.ShowAsync<EditMessageDialog>("", parameters);
            var result = await dialog.Result;
            if (!result.Canceled)
            {
                var editedContent = (string) result.Data;
                await ChatService.EditMessageAsync(message, Project.ProjectId, editedContent, isEditorView);
                await LoadMessages(initial: true);
            }        

        }
        catch(Exception ex)
        {
            Logger.LogError($"The user is trying to modify a message that he he shouldn't be able to edit !!! This is the exception{ex}");
        }
    }

    bool _preventDefault;
    private async Task HandleKeyPress(KeyboardEventArgs e)
    {

        if (_preventDefault = e.Key == "Enter" && !e.ShiftKey )
        {
            await messageField.BlurAsync();
            if (!string.IsNullOrWhiteSpace(newMessage))
            {
                var result = await SendMessage(newMessage);

                await messageField.Clear();
                // StateHasChanged();
                await messageField.FocusAsync();
            }
        }
        if (e.Key == "Escape" && !string.IsNullOrWhiteSpace(newMessage))
        {
            await NavigateBack();
        }
    }
    private async Task NavigateBack()
    {
        var result = await ShowConfirmationDialog();
        if (!result.Canceled)
        {
            var options = new DialogOptions
            {
                CloseButton = true,
                Position = DialogPosition.BottomRight,
                NoHeader = true,
            };

            var parameters = new DialogParameters
            {
                { "userId", UserId },
                { "isAdminView", isAdminView },
                { "isEditorView", isEditorView },
                { "isClientView", isClientView },
                { "timezoneOffsetMinutes", timezoneOffsetMinutes },
            };
            ProjectState.SetProject(null);
            DialogService.Show<ChatProjectListDialog>("", parameters, options);

        }
    }
    private async Task Close()
    {
        var result = await ShowConfirmationDialog();
        if (!result.Canceled)
        {
            ProjectState.SetProject(null);
        }
        await JSRuntime.InvokeVoidAsync("document.body.classList.remove", "chat-open");
    }

    private async Task<DialogResult> ShowConfirmationDialog()
    {
        if (!string.IsNullOrEmpty(newMessage))
        {
            var parameters = new DialogParameters
            {
                { "Message", "There is an unsent message. Are you sure you want to close?" }
            };

            var dialog = DialogService.Show<ConfirmationDialog>("Confirmation", parameters);

            return await dialog.Result;
        }

        return DialogResult.Ok(true); 
    }
    private ElementReference chatContainerRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initializeFocusTrap", chatContainerRef);
            // Focus the message input field
            if (messageField != null)
            {
                await messageField.FocusAsync();
            }
        }
    }
}
<style>
    .mud-dialog-width-md {
        padding: 0% !important;
    }
</style>
<script>
    window.getTimezoneOffset = function () {
        return -new Date().getTimezoneOffset(); // Offset in minutes, negative for UTC-
    };
    window.getScrollTop = function (selector) {
        const element = document.querySelector(selector);
        return element ? element.scrollTop : 0;
    };
    window.setupInitialScrollListener = function (dotNetHelper) {
        const element = document.querySelector('.chat-content');
        if (!element) return;

        let hasUserScrolled = false;

        const scrollHandler = () => {
            if (!hasUserScrolled) {
                hasUserScrolled = true;
                // Invoke the .NET method
                dotNetHelper.invokeMethodAsync('OnInitialScrollComplete');
                element.removeEventListener('scroll', scrollHandler);
            }
        };

        element.addEventListener('scroll', scrollHandler);
    };
    window.getCurrentScrollPositionFromBottom = function (selector) {
        const element = document.querySelector(selector);
        if (!element) return 0;
        return element.scrollHeight - element.scrollTop - element.clientHeight;
    };

    window.restoreScrollPositionFromBottom = function (selector, additionalHeight) {
        const element = document.querySelector(selector);
        if (!element) return;
        element.scrollTop = element.scrollHeight - element.clientHeight - additionalHeight;
    };
    window.getElementWithMessageIndexInView = function (selector) {
        // Adjust selector to match chat-messages and message-container within it
        const elements = document.querySelectorAll(`${selector} .message-container`);
        let inView = null;

        elements.forEach(element => {
            const rect = element.getBoundingClientRect();

            // Check if the element is partially visible in the viewport
            if (rect.top <= window.innerHeight && rect.bottom >= 0) {
                inView = element;
            }
        });

        // Get the value of --message-index from the element in view
        const messageIndex = inView ? inView.style.getPropertyValue('--message-index') : null;
        return messageIndex;
    };

    window.initializeFocusTrap = (element) => {
        const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

        element.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                const focusable = Array.from(element.querySelectorAll(focusableElements))
                    .filter(el => !el.disabled && el.offsetParent !== null);

                const firstFocusable = focusable[0];
                const lastFocusable = focusable[focusable.length - 1];

                if (e.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        e.preventDefault();
                    }
                } else {
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        e.preventDefault();
                    }
                }
            }

            // Add escape key handling
            if (e.key === 'Escape') {
                // Call your close method
                element.querySelector('.close-button')?.click();
            }
        });
    };
</script>
